## scroll-snap-type
该CSS属性拥有下面这些值：

none：当这个滚动容器的可视的 viewport 是滚动的，不做任何处理。
x：滚动容器只捕捉其水平轴上的捕捉位置。
y：滚动容器只捕捉其垂直轴上的捕捉位置。
block：滚动容器仅捕捉到其块轴上的捕捉位置。
inline：滚动容器仅捕捉到其内联轴上的捕捉位置。
both：滚动容器会独立捕捉到其两个轴上的位置（可能会捕捉到每个轴上的不同元素）。
mandatory：如果滚动容器被滚动，那么它超过临界值后会自动滚动到下个容器上。
proximity：如果滚动容器被滚动，那么它超过临界值后不会自动滚动到下个容器上。

其中需要注意的就是上面粗体标注的几个属性，使用mandatory就是全屏滚动，则当滚动过一定阈值后，会自动滚动到下一屏幕，如果没有滚动过某一阈值，则回弹。
而proximity不一样的是：滚动过一定阈值后，就可以正常进行滚动（而mandatory是直接进入下一屏），如果没有滚动过某一阈值，则回弹。
理解这两个属性其实非常简单，将上面的代码改改自己体验下就明白了。
注：使用mandatory，如果滚动容器的高度已经大于屏幕的高度时需要慎用，因为可能会导致有一部分内容因为强制滚屏的原因导致阅读起来非常困难。


## scroll-snap-align
该CSS属性拥有下面这些值：

none：该容器不会进行定义在父容器上面对应轴的捕捉。
start：该容器被捕捉的位置是该容器开始的部分。
end：该容器被捕捉的位置是该容器结束的部分。
center：该容器被捕捉的位置是该容器中间的部分。

用一张图可以很形象的明白这些属性所代表的容器位置：

5. 最后
因为我看到scroll-snap的其它属性大部分都存在很严重的兼容性问题，所以就不在这里细讲了，如果有兴趣的话可以到CSS Scroll Snap直接查看，不过使用上面的这两个属性其实已经完全够用了。
参考文章：

scroll-snap-align MDN
scroll-snap-type MDN
Practical CSS Scroll Snapping

作者：沧沧凉凉
链接：https://juejin.cn/post/6937855892234698759
